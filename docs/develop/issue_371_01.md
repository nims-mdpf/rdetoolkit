# Issue #371 - Task 01: Create invoice generator service module

## Overview
Create the core service module `src/rdetoolkit/invoice_generator.py` that provides the main API function `generate_invoice_from_schema()` and supporting helper functions for generating invoice.json from invoice.schema.json.

## Related Information
- **Input Source**: `local/develop/issue_371.md`
- **Overview Document**: `docs/develop/issue_371_overview.md`
- **Dependencies**: None (foundational task)

## Target Files
- [x] `src/rdetoolkit/invoice_generator.py` (new file)
- [x] `tests/invoice_generator/__init__.py` (new file)
- [x] `tests/invoice_generator/test_invoice_generator.py` (new file)

## Implementation Steps

### Step 1: Create module with main API function
```python
# src/rdetoolkit/invoice_generator.py
from __future__ import annotations

from pathlib import Path
from typing import Any

from rdetoolkit.fileops import readf_json, writef_json
from rdetoolkit.models.invoice_schema import InvoiceSchemaJson
from rdetoolkit.validation import InvoiceValidator


def generate_invoice_from_schema(
    schema_path: Path | str,
    output_path: Path | str | None = None,
    *,
    fill_defaults: bool = True,
    required_only: bool = False,
) -> dict[str, Any]:
    """Generate invoice.json from invoice.schema.json.

    Creates a valid invoice.json file based on the structure and requirements
    defined in invoice.schema.json. Supports both minimal (required fields only)
    and complete (with defaults) generation modes.

    Args:
        schema_path: Path to invoice.schema.json file.
        output_path: Optional path to write generated invoice.json.
            If None, returns dict without writing to file.
        fill_defaults: If True, populate type-based default values.
            Honors 'default' and 'examples' from schema when present.
        required_only: If True, only include required fields from schema.
            If False, include all properties defined in schema.

    Returns:
        dict[str, Any]: Generated invoice data structure.

    Raises:
        FileNotFoundError: If schema_path does not exist.
        ValueError: If schema is invalid or missing required sections.
        InvoiceSchemaValidationError: If generated invoice fails validation.

    Examples:
        >>> # Generate with all defaults, write to file
        >>> invoice = generate_invoice_from_schema(
        ...     "invoice.schema.json",
        ...     "invoice.json",
        ...     fill_defaults=True
        ... )

        >>> # Generate required fields only, return dict
        >>> invoice = generate_invoice_from_schema(
        ...     "invoice.schema.json",
        ...     required_only=True
        ... )
    """
    # Implementation here
    pass
```

### Step 2: Implement helper functions for default value generation
```python
def _get_default_value_for_type(
    value_type: str,
    *,
    schema_default: Any = None,
    schema_examples: list[Any] | None = None,
    fill_defaults: bool = True,
) -> Any:
    """Generate appropriate default value based on JSON schema type.

    Priority order:
    1. schema_default (if provided)
    2. first item from schema_examples (if fill_defaults=True and examples exist)
    3. type-based default value

    Args:
        value_type: JSON schema type ("string", "number", "integer", "boolean", "array", "object").
        schema_default: Explicit default value from schema.
        schema_examples: Example values from schema.
        fill_defaults: Whether to use examples and type-based defaults.

    Returns:
        Appropriate default value for the type.
    """
    # Implementation here
    pass


def _process_custom_field(
    custom_field: CustomField,
    *,
    fill_defaults: bool,
    required_only: bool,
    required_fields: list[str],
) -> dict[str, Any]:
    """Process custom field section from schema.

    Args:
        custom_field: CustomField model from schema.
        fill_defaults: Whether to populate default values.
        required_only: Whether to only include required fields.
        required_fields: List of required field names.

    Returns:
        Dictionary with custom field data.
    """
    # Implementation here
    pass


def _process_sample_field(
    sample_field: SampleField,
    *,
    fill_defaults: bool,
) -> dict[str, Any]:
    """Process sample field section from schema.

    Args:
        sample_field: SampleField model from schema.
        fill_defaults: Whether to populate default values.

    Returns:
        Dictionary with sample field data.
    """
    # Implementation here
    pass


def _generate_basic_section(fill_defaults: bool) -> dict[str, Any]:
    """Generate basic section with system-required fields.

    Args:
        fill_defaults: Whether to populate default values.

    Returns:
        Dictionary with basic section data.
    """
    # Implementation here
    pass
```

### Step 3: Implement schema loading and validation
```python
def _load_and_validate_schema(schema_path: Path) -> InvoiceSchemaJson:
    """Load and validate invoice schema.

    Args:
        schema_path: Path to schema file.

    Returns:
        Validated InvoiceSchemaJson model.

    Raises:
        FileNotFoundError: If schema file doesn't exist.
        ValueError: If schema is invalid.
    """
    # Implementation here
    pass
```

### Step 4: Implement invoice validation before output
```python
def _validate_generated_invoice(
    invoice_data: dict[str, Any],
    schema_path: Path,
) -> dict[str, Any]:
    """Validate generated invoice against schema.

    Args:
        invoice_data: Generated invoice data.
        schema_path: Path to schema for validation.

    Returns:
        Validated invoice data (may be modified by validator).

    Raises:
        InvoiceSchemaValidationError: If validation fails.
    """
    # Implementation here
    pass
```

### Step 5: Create comprehensive test suite
Design EP/BV test tables first, then implement tests:

**Test Categories**:
1. **Schema Loading Tests**
   - Valid schema file
   - Non-existent schema file
   - Invalid JSON format
   - Invalid schema structure

2. **Default Value Generation Tests**
   - Each type: string, number, integer, boolean, array, object
   - With schema default
   - With schema examples
   - fill_defaults=True vs False

3. **Required/Optional Fields Tests**
   - required_only=True: only required fields
   - required_only=False: all fields
   - Schema with/without 'required' array

4. **Custom Field Processing Tests**
   - Simple types (string, number, integer, boolean)
   - Complex types (with constraints: enum, pattern, min/max)
   - Required vs optional custom fields

5. **Sample Field Processing Tests**
   - With generalAttributes
   - With specificAttributes
   - Without sample section

6. **File Output Tests**
   - Write to file (output_path provided)
   - Return dict only (output_path=None)
   - Create parent directories

7. **Validation Tests**
   - Generated invoice passes validation
   - Invalid generated invoice raises error

8. **Integration Tests**
   - End-to-end with real schema files
   - Multiple schema variations

## Completion Criteria
- [x] Module `src/rdetoolkit/invoice_generator.py` created with all functions
- [x] All public functions have Google Style docstrings
- [x] All functions have complete type hints (mypy passes)
- [x] Test design tables (EP/BV) documented in test file
- [x] Unit tests implemented with 97% branch coverage (uncovered branches are defensive edge cases)
- [x] Tests follow Given/When/Then structure
- [x] `rye run pytest tests/invoice_generator/` passes (40 tests)
- [x] `rye run mypy src/rdetoolkit/invoice_generator.py` passes
- [x] `rye run ruff check src/rdetoolkit/invoice_generator.py` passes

## Notes
- Use existing `InvoiceValidator` from `validation.py` for validation
- Use `readf_json()`/`writef_json()` from `fileops.py` for file I/O
- Follow existing patterns from `invoicefile.py` for schema processing
- Reference `INVOICE_JSON` from `cmd/default.py` for expected structure
- Ensure lazy imports where appropriate to minimize startup cost
- All functions should be pure (no global state modification)

## Example Test Structure
```python
# tests/invoice_generator/test_invoice_generator.py

import pytest
from pathlib import Path
from rdetoolkit.invoice_generator import generate_invoice_from_schema


class TestGenerateInvoiceFromSchema:
    """Test suite for generate_invoice_from_schema function.

    EP/BV Test Design:
    ==================

    | Test Case | schema_path | output_path | fill_defaults | required_only | Expected Result |
    |-----------|-------------|-------------|---------------|---------------|-----------------|
    | EP-001    | valid       | None        | True          | False         | dict with all fields + defaults |
    | EP-002    | valid       | valid path  | True          | False         | file created + dict returned |
    | EP-003    | valid       | None        | False         | False         | dict with all fields, no defaults |
    | EP-004    | valid       | None        | True          | True          | dict with required fields only |
    | BV-001    | non-existent| None        | True          | False         | FileNotFoundError |
    | BV-002    | invalid JSON| None        | True          | False         | ValueError |
    | ...       | ...         | ...         | ...           | ...           | ... |
    """

    def test_ep001_generate_with_defaults_return_dict(self, tmp_path):
        # Given: Valid schema file
        schema_path = tmp_path / "invoice.schema.json"
        # ... create test schema

        # When: Generate with fill_defaults=True, required_only=False
        result = generate_invoice_from_schema(
            schema_path,
            fill_defaults=True,
            required_only=False
        )

        # Then: Returns dict with all fields and default values
        assert isinstance(result, dict)
        assert "datasetId" in result
        assert "basic" in result
        # ... more assertions
```
