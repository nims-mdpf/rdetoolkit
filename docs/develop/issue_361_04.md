# Issue #361 - Task 04: Improve Pydantic Validation Error Messages

## Overview
Improve pydantic ValidationError handling to provide field-specific error messages that explain which configuration field failed validation and why. Convert generic pydantic errors into user-friendly ConfigError messages.

## Related Information
- **Input Source**: `local/develop/issue_361.md`
- **Overview Document**: `docs/develop/issue_361_overview.md`
- **Dependencies**: Task 01 (ConfigError class)

## Target Files
- [x] `src/rdetoolkit/config.py` (modify parse_config_file and get_config)
- [x] `tests/test_config.py` (add validation error tests)

## Implementation Steps

### Step 1: Add helper function to format validation errors
Create a helper function to extract field-specific information from pydantic ValidationError.

**Location**: `src/rdetoolkit/config.py`, add new function

```python
def _format_validation_error(
    validation_error: ValidationError,
    file_path: str,
) -> ConfigError:
    """Format pydantic ValidationError into user-friendly ConfigError.

    Args:
        validation_error: The pydantic ValidationError
        file_path: Path to the configuration file

    Returns:
        ConfigError with detailed field-level information
    """
    errors = validation_error.errors()

    if not errors:
        return ConfigError(
            "Configuration validation failed",
            file_path=file_path,
            error_type="validation_error",
        )

    # Take the first error for the main message
    first_error = errors[0]
    field_path = ".".join(str(loc) for loc in first_error["loc"])
    error_msg = first_error["msg"]
    error_type_detail = first_error["type"]

    # Build detailed message
    message_parts = [f"Invalid configuration in '{file_path}'"]

    if field_path:
        message_parts.append(f"Field '{field_path}' validation failed: {error_msg}")
    else:
        message_parts.append(f"Validation failed: {error_msg}")

    # Add information about expected values if available
    if "input" in first_error:
        input_value = first_error["input"]
        message_parts.append(f"Provided value: {input_value!r}")

    # For extended_mode, provide specific guidance
    if "extended_mode" in field_path and "enum" in error_type_detail.lower():
        message_parts.append(
            "Valid values for 'extended_mode': ['rdeformat', 'MultiDataTile']"
        )

    # Add validation error context if multiple errors exist
    if len(errors) > 1:
        message_parts.append(
            f"Note: {len(errors)} validation error(s) found. Showing the first one."
        )

    full_message = "\n".join(message_parts)

    return ConfigError(
        full_message,
        file_path=file_path,
        error_type="validation_error",
        field_name=field_path,
    )
```

### Step 2: Update parse_config_file to use the helper
Modify `parse_config_file()` to catch ValidationError and use the formatting helper.

**Location**: `src/rdetoolkit/config.py`, function `parse_config_file()`

```python
from pydantic import ValidationError

def parse_config_file(*, path: str | None = None) -> Config:
    """Parse the configuration file and return a Config object.

    # ... docstring ...
    """
    # ... existing code for file loading ...

    try:
        return Config(**config_data)
    except ValidationError as e:
        # Use helper to format validation error
        if path:
            raise _format_validation_error(e, path) from e
        else:
            # Fallback for when path is None
            raise ConfigError(
                f"Configuration validation failed: {str(e)}",
                error_type="validation_error",
            ) from e
```

### Step 3: Update get_config to use the helper
Modify `get_config()` to provide better validation error messages.

**Location**: `src/rdetoolkit/config.py`, function `get_config()`

```python
def get_config(target_dir_path: RdeFsPath) -> Config | None:
    """Retrieves the configuration from the specified directory path.

    # ... docstring ...
    """
    # ... existing directory existence check from Task 02 ...

    for cfg_file in find_config_files(target_dir_path):
        try:
            __config = parse_config_file(path=cfg_file)
        except ValidationError as e:
            # Use helper to format validation error with file path
            raise _format_validation_error(e, cfg_file) from e
        if __config is not None:
            return __config

    pyproject_toml_path = get_pyproject_toml()
    if pyproject_toml_path is not None:
        try:
            __config = parse_config_file(path=str(pyproject_toml_path))
        except ValidationError as e:
            # Use helper for pyproject.toml validation errors
            raise _format_validation_error(e, str(pyproject_toml_path)) from e
        if __config is not None:
            return __config

    return None
```

### Step 4: Add unit tests for validation errors

**Location**: `tests/test_config.py`

Add test fixtures and test cases:

```python
@pytest.fixture()
def config_yaml_invalid_extended_mode():
    """Create YAML with invalid extended_mode value."""
    dirname = Path("tasksupport")
    dirname.mkdir(exist_ok=True)
    system_data = {
        "extended_mode": "invalid_mode",  # Invalid value
        "save_raw": True,
    }
    data = {"system": system_data}
    test_yaml_path = dirname.joinpath("rdeconfig.yaml")

    with open(test_yaml_path, mode="w", encoding="utf-8") as f:
        yaml.dump(data, f)

    yield test_yaml_path

    if test_yaml_path.exists():
        test_yaml_path.unlink()
    if dirname.exists():
        dirname.rmdir()


@pytest.fixture()
def config_yaml_invalid_field_type():
    """Create YAML with invalid field type."""
    dirname = Path("tasksupport")
    dirname.mkdir(exist_ok=True)
    system_data = {
        "extended_mode": "rdeformat",
        "save_raw": "not_a_boolean",  # Should be bool, not string
    }
    data = {"system": system_data}
    test_yaml_path = dirname.joinpath("rdeconfig.yaml")

    with open(test_yaml_path, mode="w", encoding="utf-8") as f:
        yaml.dump(data, f)

    yield test_yaml_path

    if test_yaml_path.exists():
        test_yaml_path.unlink()
    if dirname.exists():
        dirname.rmdir()


def test_validation_error_invalid_extended_mode(config_yaml_invalid_extended_mode):
    """Test ConfigError with field info for invalid extended_mode.

    Test ID: TC-VAL-MODE-001
    """
    # Given: config with invalid extended_mode value
    yaml_path = str(config_yaml_invalid_extended_mode)

    # When: attempting to parse the config
    # Then: ConfigError with field name and valid values
    with pytest.raises(ConfigError) as exc_info:
        parse_config_file(path=yaml_path)

    error = exc_info.value
    assert error.file_path == yaml_path
    assert error.error_type == "validation_error"
    assert error.field_name is not None
    assert "extended_mode" in error.field_name
    # Should mention valid values
    assert "rdeformat" in str(error) or "MultiDataTile" in str(error)
    assert "https://nims-mdpf.github.io/rdetoolkit/" in str(error)


def test_validation_error_invalid_field_type(config_yaml_invalid_field_type):
    """Test ConfigError for field type validation errors.

    Test ID: TC-VAL-TYPE-001
    """
    # Given: config with wrong field type
    yaml_path = str(config_yaml_invalid_field_type)

    # When: attempting to parse the config
    # Then: ConfigError with field name and type error message
    with pytest.raises(ConfigError) as exc_info:
        parse_config_file(path=yaml_path)

    error = exc_info.value
    assert error.file_path == yaml_path
    assert error.error_type == "validation_error"
    assert error.field_name is not None
    assert "save_raw" in error.field_name
    assert "https://nims-mdpf.github.io/rdetoolkit/" in str(error)


def test_get_config_validation_error(config_yaml_invalid_extended_mode):
    """Test get_config raises ConfigError for validation failures.

    Test ID: TC-VAL-GETCONF-001
    """
    # Given: directory with invalid config file
    config_dir = Path("tasksupport")

    # When: attempting to get config from directory
    # Then: ConfigError is raised with field details
    with pytest.raises(ConfigError) as exc_info:
        get_config(config_dir)

    error = exc_info.value
    assert error.error_type == "validation_error"
    assert "extended_mode" in (error.field_name or "")
    assert config_dir.name in error.file_path or str(config_dir) in str(error)


def test_validation_error_traceback_settings_invalid_format():
    """Test validation error for invalid traceback format.

    Test ID: TC-VAL-TB-001
    """
    # Given: config data with invalid traceback format
    config_data = {
        "system": {"extended_mode": "rdeformat"},
        "traceback": {"format": "invalid_format"},
    }

    # When: attempting to create Config
    # Then: ValidationError is raised
    with pytest.raises(ValidationError) as exc_info:
        Config(**config_data)

    # Verify the error mentions valid formats
    error_str = str(exc_info.value)
    assert "format" in error_str.lower()


def test_validation_error_multiple_fields():
    """Test validation error message mentions multiple errors.

    Test ID: TC-VAL-MULTI-001
    """
    # Given: config with multiple validation errors
    config_data = {
        "system": {
            "extended_mode": "invalid_mode",
            "save_raw": "not_boolean",
        },
        "traceback": {
            "format": "invalid_format",
            "max_locals_size": -1,
        },
    }

    # When: attempting to create Config
    # Then: ValidationError with multiple errors
    with pytest.raises(ValidationError) as exc_info:
        Config(**config_data)

    errors = exc_info.value.errors()
    # Should have multiple validation errors
    assert len(errors) >= 2
```

## Completion Criteria
- [x] Helper function `_format_validation_error()` created
- [x] parse_config_file uses helper to format ValidationError
- [x] get_config uses helper to format ValidationError
- [x] Error messages specify which field failed validation
- [x] Error messages explain why validation failed
- [x] Extended_mode errors list valid values
- [x] Multiple validation errors mentioned in message
- [x] Tests for invalid extended_mode value (1+ test case)
- [x] Tests for invalid field types (1+ test case)
- [x] Tests for multiple validation errors (1+ test case)
- [x] Tests verify field_name attribute is populated
- [x] Tests pass (`tox -e py312-module -- tests/test_config.py`)
- [x] No new type errors (`tox -e mypy`)
- [x] Code follows project style (`tox -e ruff`)

## Notes
- Pydantic ValidationError provides structured error information
- Field path is accessible via error["loc"] (tuple of field names)
- Error message is in error["msg"]
- Input value that failed validation is in error["input"]
- Multiple errors may exist; show first one prominently, mention others
- Extended_mode validator in SystemSettings already provides good error message
