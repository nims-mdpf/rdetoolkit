# Issue #361 - Task 05: Add Comprehensive Unit Tests for Error Scenarios

## Overview
Create comprehensive test suite following project testing standards (Equivalence Partitioning, Boundary Value Analysis, Given/When/Then pattern) to achieve 100% branch coverage for all configuration error scenarios.

## Related Information
- **Input Source**: `local/develop/issue_361.md`
- **Overview Document**: `docs/develop/issue_361_overview.md`
- **Dependencies**: Tasks 01-04 (all error handling implementations)

## Target Files
- [ ] `tests/test_config.py` (consolidate and extend all error scenario tests)

## Test Design Tables

### Equivalence Partitioning Table

| API | Input/State Partition | Rationale | Expected Outcome | Test ID |
|-----|----------------------|-----------|------------------|---------|
| `parse_config_file` | Valid YAML file with correct schema | Valid input | Returns Config object | TC-EP-001 |
| `parse_config_file` | Valid TOML file with correct schema | Valid input | Returns Config object | TC-EP-002 |
| `parse_config_file` | Non-existent file path | Invalid - file missing | ConfigError with file_not_found | TC-EP-003 |
| `parse_config_file` | YAML file with syntax error | Invalid - parse error | ConfigError with parse_error, line info | TC-EP-004 |
| `parse_config_file` | TOML file with syntax error | Invalid - parse error | ConfigError with parse_error | TC-EP-005 |
| `parse_config_file` | Valid YAML with invalid extended_mode | Invalid - validation | ConfigError with validation_error, field name | TC-EP-006 |
| `parse_config_file` | Valid YAML with wrong field types | Invalid - validation | ConfigError with validation_error | TC-EP-007 |
| `parse_config_file` | File with no read permissions | Invalid - I/O error | ConfigError with io_error | TC-EP-008 |
| `parse_config_file` | Empty YAML file (None content) | Edge case | Returns default Config | TC-EP-009 |
| `get_config` | Directory with valid config file | Valid input | Returns Config object | TC-EP-010 |
| `get_config` | Non-existent directory | Invalid - directory missing | ConfigError with directory_not_found | TC-EP-011 |
| `get_config` | Directory with invalid config | Invalid - validation | ConfigError with validation_error | TC-EP-012 |
| `get_config` | Directory with no config files | Edge case | Returns None or searches for pyproject.toml | TC-EP-013 |

### Boundary Value Table

| API | Boundary | Rationale | Expected Outcome | Test ID |
|-----|----------|-----------|------------------|---------|
| `ConfigError` | line_number = None | Lower boundary | Error message without line info | TC-BV-001 |
| `ConfigError` | line_number = 1 | Min valid value | Error message includes "line 1" | TC-BV-002 |
| `ConfigError` | line_number = 999 | High value | Error message includes "line 999" | TC-BV-003 |
| `ConfigError` | column_number = None | Lower boundary | Error message without column info | TC-BV-004 |
| `ConfigError` | column_number = 1 | Min valid value | Error message includes "column 1" | TC-BV-005 |
| `ConfigError` | field_name = None | No field specified | Generic validation error | TC-BV-006 |
| `ConfigError` | field_name = "system.extended_mode" | Nested field | Error message includes full field path | TC-BV-007 |

## Implementation Steps

### Step 1: Create test design documentation

Add test design tables at the top of the test module:

**Location**: `tests/test_config.py`, add at module level

```python
"""
Configuration Loading Error Handling Tests

This module tests error scenarios for configuration file loading,
following Issue #361 requirements for improved error messages.

Test Design:
-----------

Equivalence Partitioning (see table in docs/develop/issue_361_05.md)
Boundary Value Analysis (see table in docs/develop/issue_361_05.md)

All tests follow Given/When/Then pattern and verify:
1. Correct exception type (ConfigError)
2. Error type attribute (file_not_found, parse_error, validation_error, etc.)
3. File path included in error
4. Line/column information when available
5. Field name for validation errors
6. Documentation URL in all errors
"""
```

### Step 2: Implement comprehensive error scenario tests

Add the following test cases to achieve 100% branch coverage:

```python
# ============================================================================
# File Not Found Error Tests (TC-EP-003, TC-EP-011)
# ============================================================================

def test_parse_config_file_not_found__tc_ep_003():
    """Test ConfigError for non-existent file.

    Test ID: TC-EP-003
    """
    # Given: non-existent config file path
    nonexistent_path = "nonexistent_config_12345.yaml"

    # When: attempting to parse the file
    # Then: ConfigError with file_not_found type
    with pytest.raises(ConfigError) as exc_info:
        parse_config_file(path=nonexistent_path)

    error = exc_info.value
    assert error.file_path == nonexistent_path
    assert error.error_type == "file_not_found"
    assert "not found" in str(error).lower()
    assert "gen-config" in str(error)
    assert "https://nims-mdpf.github.io/rdetoolkit/" in str(error)


def test_get_config_directory_not_found__tc_ep_011():
    """Test ConfigError for non-existent directory.

    Test ID: TC-EP-011
    """
    # Given: non-existent directory
    nonexistent_dir = Path("nonexistent_dir_12345")

    # When: attempting to get config
    # Then: ConfigError with directory_not_found
    with pytest.raises(ConfigError) as exc_info:
        get_config(nonexistent_dir)

    error = exc_info.value
    assert error.error_type == "directory_not_found"
    assert str(nonexistent_dir) in error.file_path


# ============================================================================
# Parse Error Tests (TC-EP-004, TC-EP-005, TC-EP-008)
# ============================================================================

@pytest.fixture()
def yaml_with_syntax_error(tmp_path):
    """YAML file with syntax error at known line."""
    yaml_file = tmp_path / "bad_syntax.yaml"
    content = """
system:
  extended_mode: rdeformat
  invalid_list: [
    unclosed bracket
multidata_tile:
  ignore_errors: false
"""
    yaml_file.write_text(content)
    yield yaml_file


def test_parse_yaml_syntax_error__tc_ep_004(yaml_with_syntax_error):
    """Test ConfigError with line info for YAML syntax error.

    Test ID: TC-EP-004
    """
    # Given: YAML file with syntax error
    yaml_path = str(yaml_with_syntax_error)

    # When: parsing the file
    # Then: ConfigError with parse_error and line number
    with pytest.raises(ConfigError) as exc_info:
        parse_config_file(path=yaml_path)

    error = exc_info.value
    assert error.error_type == "parse_error"
    assert error.file_path == yaml_path
    # YAML parser should provide line number
    assert error.line_number is not None or "line" in str(error).lower()
    assert "https://nims-mdpf.github.io/rdetoolkit/" in str(error)


@pytest.fixture()
def toml_with_syntax_error(tmp_path):
    """TOML file with syntax error."""
    toml_file = tmp_path / "pyproject.toml"
    content = """
[tool.rdetoolkit.system]
extended_mode = "rdeformat
save_raw = true
"""
    toml_file.write_text(content)
    yield toml_file


def test_parse_toml_syntax_error__tc_ep_005(toml_with_syntax_error):
    """Test ConfigError for TOML syntax error.

    Test ID: TC-EP-005
    """
    # Given: TOML file with syntax error
    toml_path = str(toml_with_syntax_error)

    # When: parsing the file
    # Then: ConfigError with parse_error
    with pytest.raises(ConfigError) as exc_info:
        parse_config_file(path=toml_path)

    error = exc_info.value
    assert error.error_type == "parse_error"
    assert error.file_path == toml_path


def test_parse_yaml_io_error__tc_ep_008(tmp_path):
    """Test ConfigError for file I/O errors.

    Test ID: TC-EP-008
    """
    # Given: YAML file with no read permissions
    yaml_file = tmp_path / "unreadable.yaml"
    yaml_file.write_text("system:\n  extended_mode: rdeformat")
    yaml_file.chmod(0o000)

    try:
        # When: attempting to read the file
        # Then: ConfigError with io_error
        with pytest.raises(ConfigError) as exc_info:
            parse_config_file(path=str(yaml_file))

        error = exc_info.value
        assert error.error_type == "io_error"
    finally:
        yaml_file.chmod(0o644)


# ============================================================================
# Validation Error Tests (TC-EP-006, TC-EP-007, TC-EP-012)
# ============================================================================

@pytest.fixture()
def yaml_invalid_extended_mode(tmp_path):
    """YAML with invalid extended_mode value."""
    yaml_file = tmp_path / "rdeconfig.yaml"
    data = {
        "system": {
            "extended_mode": "invalid_mode_xyz",
            "save_raw": True,
        }
    }
    with open(yaml_file, "w") as f:
        yaml.dump(data, f)
    yield yaml_file


def test_validation_error_invalid_mode__tc_ep_006(yaml_invalid_extended_mode):
    """Test ConfigError for invalid extended_mode.

    Test ID: TC-EP-006
    """
    # Given: config with invalid extended_mode
    yaml_path = str(yaml_invalid_extended_mode)

    # When: parsing the config
    # Then: ConfigError with validation_error and field name
    with pytest.raises(ConfigError) as exc_info:
        parse_config_file(path=yaml_path)

    error = exc_info.value
    assert error.error_type == "validation_error"
    assert error.field_name is not None
    assert "extended_mode" in error.field_name
    # Should list valid values
    assert "rdeformat" in str(error) or "MultiDataTile" in str(error)


@pytest.fixture()
def yaml_wrong_field_types(tmp_path):
    """YAML with wrong field types."""
    yaml_file = tmp_path / "rdeconfig.yaml"
    data = {
        "system": {
            "save_raw": "not_a_boolean",
            "save_thumbnail_image": 123,
        }
    }
    with open(yaml_file, "w") as f:
        yaml.dump(data, f)
    yield yaml_file


def test_validation_error_wrong_types__tc_ep_007(yaml_wrong_field_types):
    """Test ConfigError for wrong field types.

    Test ID: TC-EP-007
    """
    # Given: config with wrong field types
    yaml_path = str(yaml_wrong_field_types)

    # When: parsing the config
    # Then: ConfigError with validation_error
    with pytest.raises(ConfigError) as exc_info:
        parse_config_file(path=yaml_path)

    error = exc_info.value
    assert error.error_type == "validation_error"
    assert error.field_name is not None


# ============================================================================
# Boundary Value Tests (TC-BV-001 to TC-BV-007)
# ============================================================================

def test_config_error_no_line_info__tc_bv_001():
    """Test ConfigError message without line information.

    Test ID: TC-BV-001
    """
    # Given: ConfigError with line_number = None
    error = ConfigError(
        "Test error",
        file_path="/path/to/config.yaml",
        error_type="test_error",
        line_number=None,
    )

    # When: converting to string
    error_str = str(error)

    # Then: no line information in message
    assert "line" not in error_str.lower() or "location:" not in error_str.lower()
    assert "/path/to/config.yaml" in error_str


def test_config_error_with_line_1__tc_bv_002():
    """Test ConfigError with line number 1.

    Test ID: TC-BV-002
    """
    # Given: ConfigError with line_number = 1
    error = ConfigError(
        "Test error",
        file_path="/path/to/config.yaml",
        error_type="test_error",
        line_number=1,
    )

    # When: converting to string
    error_str = str(error)

    # Then: includes "line 1"
    assert "line 1" in error_str.lower()


def test_config_error_with_high_line__tc_bv_003():
    """Test ConfigError with high line number.

    Test ID: TC-BV-003
    """
    # Given: ConfigError with line_number = 999
    error = ConfigError(
        "Test error",
        error_type="test_error",
        line_number=999,
    )

    # When: converting to string
    error_str = str(error)

    # Then: includes "line 999"
    assert "line 999" in error_str.lower()


def test_config_error_with_column__tc_bv_005():
    """Test ConfigError with column information.

    Test ID: TC-BV-005
    """
    # Given: ConfigError with line and column
    error = ConfigError(
        "Test error",
        error_type="test_error",
        line_number=10,
        column_number=1,
    )

    # When: converting to string
    error_str = str(error)

    # Then: includes both line and column
    assert "line 10" in error_str.lower()
    assert "column 1" in error_str.lower()


def test_config_error_nested_field__tc_bv_007():
    """Test ConfigError with nested field path.

    Test ID: TC-BV-007
    """
    # Given: ConfigError with nested field name
    error = ConfigError(
        "Test error",
        error_type="validation_error",
        field_name="system.extended_mode",
    )

    # When: converting to string
    error_str = str(error)

    # Then: includes full field path
    assert "system.extended_mode" in error_str


# ============================================================================
# Edge Cases and Integration Tests
# ============================================================================

def test_parse_empty_yaml_file__tc_ep_009(tmp_path):
    """Test parsing empty YAML file returns default Config.

    Test ID: TC-EP-009
    """
    # Given: empty YAML file
    yaml_file = tmp_path / "rdeconfig.yaml"
    yaml_file.write_text("")

    # When: parsing the file
    config = parse_config_file(path=str(yaml_file))

    # Then: returns Config with defaults (no error)
    assert isinstance(config, Config)
    assert config.system.extended_mode is None


def test_get_config_no_config_files__tc_ep_013(tmp_path):
    """Test get_config with directory containing no config files.

    Test ID: TC-EP-013
    """
    # Given: empty directory
    empty_dir = tmp_path / "empty"
    empty_dir.mkdir()

    # When: attempting to get config
    config = get_config(empty_dir)

    # Then: returns None or searches for pyproject.toml
    # (Behavior depends on implementation)
    assert config is None or isinstance(config, Config)
```

### Step 3: Add coverage validation

Add a test to ensure all error paths are covered:

```python
def test_coverage_all_error_types():
    """Verify all error types are tested.

    This test documents which error types should be covered.
    """
    tested_error_types = {
        "file_not_found",
        "directory_not_found",
        "parse_error",
        "io_error",
        "validation_error",
    }

    # All error types should have corresponding test cases
    assert len(tested_error_types) >= 5
```

## Completion Criteria
- [ ] Test design tables documented at module level
- [ ] All equivalence partitions tested (13 test cases: TC-EP-001 to TC-EP-013)
- [ ] All boundary values tested (7 test cases: TC-BV-001 to TC-BV-007)
- [ ] All tests follow Given/When/Then pattern
- [ ] Each test verifies error type, file path, and documentation URL
- [ ] Line/column information verified when applicable
- [ ] Field name verified for validation errors
- [ ] Negative test cases â‰¥ positive test cases
- [ ] Branch coverage reaches 100% for config error handling
- [ ] All tests pass (`tox -e py312-module -- tests/test_config.py`)
- [ ] Coverage report generated (`pytest --cov=rdetoolkit.config --cov-branch --cov-report=html`)
- [ ] No new type errors (`tox -e mypy`)
- [ ] Code follows project style (`tox -e ruff`)

## Execution Commands

### Direct pytest execution
```bash
# Run all config tests with coverage
pytest tests/test_config.py -v \
  --cov=rdetoolkit.config \
  --cov-branch \
  --cov-report=term-missing \
  --cov-report=html

# Run specific test
pytest tests/test_config.py::test_parse_config_file_not_found__tc_ep_003 -v
```

### Via tox
```bash
# Run all tests
tox -e py312-module -- tests/test_config.py

# Run with coverage
tox -e py312-module -- tests/test_config.py --cov=rdetoolkit.config --cov-branch
```

## Notes
- This task consolidates all error scenario tests from Tasks 02-04
- Some tests may already exist from previous tasks; extend rather than duplicate
- Fixtures should be reusable across multiple test cases
- Clean up temporary files in fixture teardown
- Test IDs (TC-EP-XXX, TC-BV-XXX) provide traceability to test design tables
- Each error type should be tested at least twice (positive and negative cases)
